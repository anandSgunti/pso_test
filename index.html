<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Image on Horizontal Surface</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-ar@6.0.1/dist/aframe-ar.min.js"></script>
</head>
<body>
    <a-scene webxr="optionalFeatures: hit-test, local-floor;" ar-hit-test="target:#my-image;">
        <a-assets>
            <img id="local-image" src="Person.jpg">
        </a-assets>

        <a-image
            id="my-image"
            src="#local-image"
            rotation="-90 0 0"
            width="1"
            height="1"
            visible="false"
        ></a-image>

        <a-camera></a-camera>
    </a-scene>

    <script>
        AFRAME.registerComponent('ar-hit-test', {
            schema: {
                target: {type: 'selector'}
            },
            init: function () {
                this.xrHitTestSource = null;
                this.viewerSpace = null;
                this.refSpace = null;

                this.el.sceneEl.renderer.xr.addEventListener('sessionstart', (ev) => {
                    this.session = this.el.sceneEl.renderer.xr.getSession();
                    this.initHitTestSource();
                });
                this.el.sceneEl.renderer.xr.addEventListener('sessionend', (ev) => {
                    this.xrHitTestSource = null;
                });
            },
            tick: function () {
                if (this.xrHitTestSource) {
                    this.checkHits();
                }
            },
            initHitTestSource: function () {
                const self = this;
                const session = this.session;

                session.requestReferenceSpace('viewer').then((space) => {
                    this.viewerSpace = space;
                    session.requestHitTestSource({space: this.viewerSpace})
                        .then((hitTestSource) => {
                            this.xrHitTestSource = hitTestSource;
                        });
                });

                session.requestReferenceSpace('local').then((space) => {
                    this.refSpace = space;
                });
            },
            checkHits: function () {
                const frame = this.el.sceneEl.frame;
                if (!frame) return;

                const xrViewerPose = frame.getViewerPose(this.refSpace);
                if (this.xrHitTestSource && xrViewerPose) {
                    const hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(this.refSpace);

                        this.data.target.setAttribute('position', pose.transform.position);
                        this.data.target.setAttribute('visible', 'true');
                    }
                }
            }
        });
    </script>
</body>
</html>
